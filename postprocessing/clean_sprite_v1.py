"""
Script intended to clean a sprite generated by our model. It will downsample, reduce color palette and finally remove magenta background.
"""

import os, argparse, time
from PIL import Image
import numpy as np
import scipy
from itertools import product


def kCentroid(image: Image, width: int, height: int, centroids: int):
    image = image.convert("RGB")

    # Create an empty array for the downscaled image
    downscaled = np.zeros((height, width, 3), dtype=np.uint8)

    # Calculate the scaling factors
    wFactor = image.width / width
    hFactor = image.height / height

    # Iterate over each tile in the downscaled image
    for x, y in product(range(width), range(height)):
        # Crop the tile from the original image
        tile = image.crop(
            (x * wFactor, y * hFactor, (x * wFactor) + wFactor, (y * hFactor) + hFactor)
        )

        # Quantize the colors of the tile using k-means clustering
        tile = tile.quantize(colors=centroids, method=1, kmeans=centroids).convert(
            "RGB"
        )

        # Get the color counts and find the most common color
        color_counts = tile.getcolors()
        most_common_color = max(color_counts, key=lambda x: x[0])[1]

        # Assign the most common color to the corresponding pixel in the downscaled image
        downscaled[y, x, :] = most_common_color

    return Image.fromarray(downscaled, mode="RGB")


def pixelate(image: Image):
    # Convert the image to a NumPy array
    npim = np.array(image)[..., :3]

    # Compute horizontal differences between pixels
    hdiff = np.sqrt(np.sum((npim[:, :-1, :] - npim[:, 1:, :]) ** 2, axis=2))
    hsum = np.sum(hdiff, 0)

    # Compute vertical differences between pixels
    vdiff = np.sqrt(np.sum((npim[:-1, :, :] - npim[1:, :, :]) ** 2, axis=2))
    vsum = np.sum(vdiff, 1)

    # Find peaks in the horizontal and vertical sums
    hpeaks, _ = scipy.signal.find_peaks(hsum, distance=1, height=0.0)
    vpeaks, _ = scipy.signal.find_peaks(vsum, distance=1, height=0.0)

    # Compute spacing between the peaks
    hspacing = np.diff(hpeaks)
    vspacing = np.diff(vpeaks)

    # Resize input image using kCentroid with the calculated horizontal and vertical factors
    return kCentroid(
        image,
        round(image.width / np.median(hspacing)),
        round(image.height / np.median(vspacing)),
        2,
    )


def determine_best_k(image: Image, max_k: int):
    # Convert the image to RGB mode
    image = image.convert("RGB")

    # Prepare arrays for distortion calculation
    pixels = np.array(image)
    pixel_indices = np.reshape(pixels, (-1, 3))

    # Calculate distortion for different values of k
    distortions = []
    for k in range(1, max_k + 1):
        quantized_image = image.quantize(colors=k, method=0, kmeans=k, dither=0)
        centroids = np.array(quantized_image.getpalette()[: k * 3]).reshape(-1, 3)

        # Calculate distortions
        distances = np.linalg.norm(pixel_indices[:, np.newaxis] - centroids, axis=2)
        min_distances = np.min(distances, axis=1)
        distortions.append(np.sum(min_distances**2))

    # Calculate the rate of change of distortions
    rate_of_change = np.diff(distortions) / np.array(distortions[:-1])

    # Find the elbow point (best k value)
    if len(rate_of_change) == 0:
        best_k = 2
    else:
        elbow_index = np.argmax(rate_of_change) + 1
        best_k = elbow_index + 2

    return best_k


def reduce_palette(image: Image, max_colors: int):
    best_k = determine_best_k(image, max_colors)
    return image.quantize(colors=best_k, method=1, kmeans=best_k, dither=0).convert(
        "RGB"
    )


def _smoothstep(x, a, b):
    t = np.clip((x - a) / max(1e-6, (b - a)), 0.0, 1.0)
    return t * t * (3.0 - 2.0 * t)


def _count_neighbors(mask):
    m = mask.astype(np.uint8)
    p = np.pad(m, ((1, 1), (1, 1)), constant_values=0)
    return (
        p[:-2, 1:-1]
        + p[2:, 1:-1]
        + p[1:-1, :-2]
        + p[1:-1, 2:]
        + p[:-2, :-2]
        + p[:-2, 2:]
        + p[2:, :-2]
        + p[2:, 2:]
    )


def _despill_vec(rgb01, alpha01, bg_dir=(1.0, 0.0, 1.0), strength=1.2):
    # remove color in the direction of the background (magenta) near transparency
    B = np.array(bg_dir, dtype=np.float32).reshape(1, 1, 3)
    B /= max(1e-6, np.linalg.norm(B))
    proj = (np.sum(rgb01 * B, axis=-1, keepdims=True)) * B
    k = strength * (1.0 - alpha01[..., None])
    return np.clip(rgb01 - k * proj, 0.0, 1.0)


def remove_background(
    img: Image.Image,
    bg_color=(255, 0, 255),
    key_lo=25,
    key_hi=220,  # widen to grab more magenta
    hard_threshold=0.40,  # used only for morphology, alpha stays soft
    open_iters=1,
    close_iters=1,
    despill_strength=1.2,
    green_spill_strength=1,
) -> Image.Image:
    im = img.convert("RGBA")
    arr = np.array(im, dtype=np.uint8)
    rgb = arr[..., :3]
    a_in = arr[..., 3] / 255.0

    # 1) soft alpha from distance to magenta (no hard thresholding)
    diff = (
        rgb.astype(np.int16) - np.array(bg_color, np.int16).reshape(1, 1, 3)
    ).astype(np.int32)
    dist = np.sqrt(np.sum(diff * diff, axis=-1)).astype(np.float32)  # 0..~441
    a_soft = _smoothstep(dist, key_lo, key_hi)
    alpha = np.minimum(a_in, a_soft)

    # 2) tiny morphology on a *hard* proxy mask to kill specks/holes
    hard = alpha > hard_threshold
    for _ in range(open_iters):
        hard = _count_neighbors(hard) >= 4  # erode
        hard = _count_neighbors(hard) > 0  # dilate
    for _ in range(close_iters):
        hard = _count_neighbors(hard) > 0  # dilate
        hard = _count_neighbors(hard) >= 4  # erode
    alpha *= hard.astype(np.float32)  # keep alpha soft

    # 3) de-matte: C = a*F + (1-a)*B  => F = (C - (1-a)B)/a
    rgb01 = rgb / 255.0
    bg01 = np.array(bg_color, np.float32).reshape(1, 1, 3) / 255.0
    a = np.clip(alpha[..., None], 0.0, 1.0)
    F = (rgb01 - (1.0 - a) * bg01) / np.maximum(a, 1e-5)
    F = np.clip(F, 0.0, 1.0)

    # 4) magenta despill near edges
    F = _despill_vec(F, alpha, bg_dir=(1.0, 0.0, 1.0), strength=despill_strength)

    # 5) optional green-spill suppression (common opposite magenta)
    if green_spill_strength > 0:
        r, g, b = F[..., 0], F[..., 1], F[..., 2]
        green_dom = (g > r * 1.15) & (g > b * 1.15)
        k = green_spill_strength * (1.0 - alpha)  # stronger where alpha is thin
        target_g = (r + b) / 2.0
        g = np.where(green_dom, g * (1 - k) + target_g * k, g)
        F = np.clip(np.stack([r, g, b], axis=-1), 0.0, 1.0)

    out = np.empty_like(arr)
    out[..., :3] = (F * 255.0 + 0.5).astype(np.uint8)
    out[..., 3] = (alpha * 255.0 + 0.5).astype(np.uint8)
    return Image.fromarray(out, "RGBA")


def clean_image(
    input_path: str,
    output_path: str,
    max_colors: int = 16,
):
    """
    Pixelate, reduce color palette and remove background.

    Args:
        input_path: Path to input image
        output_path: Path to save output image (default: "output.png")
        max_colors: Max colors for computation (default: 16)

    Returns:
        tuple: (output_image) or None if file doesn't exist
    """
    if not os.path.isfile(input_path):
        print(f"Error: File not found: {input_path}")
        return None

    image = Image.open(input_path).convert("RGB")

    # Pixelate the image
    pixelated = pixelate(image)
    pixelated.save(output_path.replace(".png", "_pixelated.png"))

    # Reduce the color palette
    reduced_palette = reduce_palette(pixelated, max_colors)
    reduced_palette.save(output_path.replace(".png", "_reduced_palette.png"))

    # Remove the magenta background
    cleaned = remove_background(reduced_palette)
    cleaned.save(output_path.replace(".png", "_cleaned.png"))

    # upscale the image to the original size with nearest neighbor
    output = cleaned.resize(image.size, Image.NEAREST)
    output.save(output_path)
    print(f"Upscaled image saved to {output_path}")

    return output


if __name__ == "__main__":
    input_dir = "output_dq"
    output_dir = "output_dq_cleaned"
    max_colors = 8

    for file in os.listdir(input_dir):
        if file.endswith(".png"):
            input_image_path = os.path.join(input_dir, file)
            output_image_path = os.path.join(output_dir, file)
            clean_image(input_image_path, output_image_path, max_colors)
